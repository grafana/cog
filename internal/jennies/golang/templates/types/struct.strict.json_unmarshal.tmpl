{{- $json := importStdPkg "encoding/json" -}}
func (resource *{{ .def.Name|upperCamelCase }}) StrictUnmarshalJSON(raw []byte) error {
	if raw == nil {
		return nil
	}

	{{- $cog := importPkg "cog" }}
	var errs cog.BuildErrors

	fields := make(map[string]json.RawMessage)
	if err := json.Unmarshal(raw, &fields); err != nil {
		return err
	}
	{{- range $field := .def.Type.Struct.Fields }}
	{{- $inputRef := print "fields[" ($field.Name|formatScalar) "]" }}
	{{- $unmarshalInto := print "resource." ($field.Name|upperCamelCase) }}
	// Field "{{ $field.Name }}"
	if fields[{{ $field.Name|formatScalar }}] != nil {
		if string(fields[{{ $field.Name|formatScalar }}]) != "null" {
			{{ template "strict_unmarshal_field_type" (dict "RawInputRef" $inputRef "InputType" $field.Type "UnmarshalInto" $unmarshalInto "ErrorBreadcrumb" $field.Name "Depth" 1) }}
		{{ if $field.Required -}} } else {
			{{- $errors := importStdPkg "errors" -}}
			errs = append(errs, cog.MakeBuildErrors({{ $field.Name|formatScalar }}, errors.New("required field is null"))...)
		{{ end }}
		}
		delete(fields, {{ $field.Name|formatScalar }})
	{{ if $field.Required -}} } else {
		{{- $errors := importStdPkg "errors" -}}
		errs = append(errs, cog.MakeBuildErrors({{ $field.Name|formatScalar }}, errors.New("required field is missing from input"))...)
	{{- end }}
	}
	{{- end }}

	{{ $fmt := importStdPkg "fmt" -}}
	for field := range fields {
		errs = append(errs, cog.MakeBuildErrors("{{ .def.Name|upperCamelCase }}", fmt.Errorf("unexpected field %s", field))...)
	}

	if len(errs) == 0 {
		return nil
	}

	return errs
}

{{/* arguments: RawInputRef, InputType, UnmarshalInto, ErrorBreadcrumb, Depth */}}
{{- define "strict_unmarshal_field_type" -}}
	{{- if or (resolvesToScalar .InputType) -}}
			if err := json.Unmarshal({{ .RawInputRef }}, &{{ .UnmarshalInto }}); err != nil {
				errs = append(errs, cog.MakeBuildErrors("{{ .ErrorBreadcrumb }}", err)...)
			}
	{{- else if and .InputType.IsRef (resolvesToStruct .InputType) }}
			{{ .UnmarshalInto }} = {{ if .InputType.Nullable}}&{{ end }}{{ formatRawRef .InputType.Ref.ReferredPkg .InputType.Ref.ReferredType }}{}
			if err := {{ .UnmarshalInto }}.StrictUnmarshalJSON({{ .RawInputRef }}); err != nil {
				errs = append(errs, cog.MakeBuildErrors("{{ .ErrorBreadcrumb }}", err)...)
			}
	{{- else if resolvesToArray .InputType }}
			{{- if resolvesToArrayOfScalars .InputType }}
			if err := json.Unmarshal({{ .RawInputRef }}, &{{ .UnmarshalInto }}); err != nil {
				errs = append(errs, cog.MakeBuildErrors("{{ .ErrorBreadcrumb }}", err)...)
			}
			{{- else }}
			{{- $arrayType := (resolveRefs .InputType).Array }}
			partialArray := []json.RawMessage{}
			if err := json.Unmarshal({{ .RawInputRef }}, &partialArray); err != nil {
				return err
			}

			for i{{ .Depth }} := range partialArray {
				{{- $strconv := importStdPkg "strconv" }}
				{{- $breadcrumb := print .ErrorBreadcrumb "[\"+strconv.Itoa(i" .Depth ")+\"]" }}
				{{- $rawInputRef := print "partialArray[i" .Depth "]" }}
				{{- $result := print "result" .Depth }}
				var {{ $result }} {{ $arrayType.ValueType|formatType }}
				{{ template "strict_unmarshal_field_type" (dict "RawInputRef" $rawInputRef "InputType" $arrayType.ValueType "UnmarshalInto" $result "ErrorBreadcrumb" $breadcrumb "Depth" (add1 .Depth)) }}
				{{ .UnmarshalInto }} = append({{ .UnmarshalInto }}, {{ $result }})
			}
			{{- end}}
	{{- else if .InputType.IsDataqueryComposableSlot }}
			dataquery, err := cog.StrictUnmarshalDataquery({{ .RawInputRef }}, "")
			if err != nil {
				errs = append(errs, cog.MakeBuildErrors("{{ .ErrorBreadcrumb }}", err)...)
			} else {
				{{ .UnmarshalInto }} = dataquery
			}
	{{- else -}}
			{{/* TODO: uncomment later → found an unimplemented unmarshal case  intentionally left uncommented, to trigger a failure during codegen */}}
			// TODO: implement me :( → {{ .InputType.Kind }}
	{{- end -}}
{{- end -}}
