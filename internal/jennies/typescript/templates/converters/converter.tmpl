{{ $converter := include "converter" . }}

{{ .Imports }}

{{ $converter }}

{{- define "guard" }}
    {{- if and (eq .Op "!=") (eq .Value nil) -}}
        {{ .Path }} != null
    {{- else -}}
        {{- $leftOperand := .Path -}}
        {{- $operator := .Op -}}
        {{- if eq .Op "minLength" -}}
            {{- $leftOperand = print $leftOperand ".length" -}}
            {{- $operator = ">=" -}}
        {{- end -}}
        {{- if eq .Op "maxLength" -}}
            {{- $leftOperand = print $leftOperand ".length" -}}
            {{- $operator = "<=" -}}
        {{- end -}}
        {{- $leftOperand }} {{ $operator}} {{ .Value | formatValue -}}
    {{- end -}}
{{- end }}

{{- define "value_formatter" -}}
    JSON.stringify({{ .Path }})
{{- end }}

{{- define "guards" }}
    {{- $guardsCount := sub1 (len .) -}}
    {{- range $i, $guard := . }}{{- template "guard" $guard }}{{ if ne $i $guardsCount }} && {{ end }}{{ end }}
{{- end }}

{{- define "prepare_arg" -}}
    {{- with .Arg.Builder -}}
        const {{ $.IntoVar }} = {{ formatRawRef .BuilderPkg (print .BuilderName "Converter") }}({{ .ValuePath }});
    {{- end -}}
    {{- with .Arg.Array -}}
        const tmp{{ $.IntoVar }}: string[] = [];
        for (const {{ .ValueAs }} of {{ .For }}) {
            {{- $subIntoVar := print "tmp" .ValueAs }}
            {{ template "prepare_arg" (dict "IntoVar" $subIntoVar "Arg" .ForArg) }}
            tmp{{ $.IntoVar }}.push({{ $subIntoVar }});
        }
        const {{ $.IntoVar }} = "[" + tmp{{ $.IntoVar }}.join(",\n") + "]";
    {{- end -}}
    {{- with .Arg.Runtime -}}
        const {{ $.IntoVar }} = cog.{{ .FuncName }}({{ range $runtimeArg := .Args }}{{ $runtimeArg.ValuePath }}, {{ end }});
    {{- end -}}
    {{- with .Arg.Direct -}}
        const {{ $.IntoVar }} = {{ template "value_formatter" (dict "Type" .ValueType "Path" .ValuePath ) -}};
    {{- end -}}
{{- end }}

{{- define "conversion_mapping" -}}
{{- $firstOpt := .Options | first }}
{{- with $firstOpt.Guards -}}if ({{ template "guards" . }}) { {{- end }}
{{ if ne .RepeatFor nil -}}for (const {{ .RepeatAs }} of {{ .RepeatFor }}) { {{- end }}
{{- range $optMapping := .Options }}
    {{ template "option_mapping" $optMapping }}
{{- end }}
{{ if ne .RepeatFor nil -}} } {{- end }}
{{- with $firstOpt.Guards -}} } {{- end }}
{{- end }}

{{- define "option_mapping" -}}
{{- $argsCount := sub1 (len .Args) -}}
{{- with .ArgumentGuards -}}if ({{ template "guards" . }}) { {{- end }}
{{- if and (eq (len .Guards) 0) (eq (len .ArgumentGuards) 0) -}} { {{- end }}
buffer += `{{ $.Option.Name }}(`;
{{- range $i, $arg := $.Args }}
    {{- $intoVar := print "arg" $i }}
    {{ template "prepare_arg" (dict "IntoVar" $intoVar "Arg" $arg) }}
    buffer += {{ $intoVar }};
    {{ if ne $i $argsCount }}buffer += ", ";{{- end }}
{{- end }}
buffer += ")";

calls.push(buffer);
buffer = "";
{{ with .ArgumentGuards -}} } {{- end }}
{{- if and (eq (len .Guards) 0) (eq (len .ArgumentGuards) 0) -}} } {{- end }}
{{- end }}

{{- define "converter" -}}
export function {{ .Converter.BuilderName | upperCamelCase }}Converter(input: {{ formatRawRef .Converter.Input.TypeRef.ReferredPkg .Converter.Input.TypeRef.ReferredType }}): string {
    {{- $constructorArgsCount := sub1 (len .Converter.ConstructorArgs) }}
    const calls: string[] = [
        `new {{ .Converter.Package }}.{{ .Converter.BuilderName | upperCamelCase }}Builder({{ range $i, $arg := .Converter.ConstructorArgs }}${ {{ $arg.ValuePath }} }{{- if ne $i $constructorArgsCount }}, {{ end }}{{ end }})`,
    ];
    let buffer: string = "";

    {{- range .Converter.Mappings }}
    {{ template "conversion_mapping" . }}
    {{- end }}

    return calls.join(".\t\n");
}
{{- end }}
